===== Demo =====

Pentru început, vrem să ne acomodăm cu cele mai importante comenzi din linia de comandă pentru rețelistică și internet.

<note tip>
Avem și un [[uso:resurse:cheatsheet|cheatsheet]] pe care îl putem folosi ca să ne reamintim cele mai frecvente comenzi.
</note>

==== 0. Vizualizarea adresei IP ====

Stația din laborator are mai multe interfețe de rețea. Pentru a afișa detalii despre ele putem folosi comanda ''ip address show''.

<code bash>

student@uso:~$ ip address show
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host
       valid_lft forever preferred_lft forever
2: ens33: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP group default qlen 1000
    link/ether 00:0c:29:8b:37:c1 brd ff:ff:ff:ff:ff:ff
    inet 192.168.232.206/24 brd 192.168.232.255 scope global dynamic noprefixroute ens33
       valid_lft 982sec preferred_lft 982sec
    inet6 fe80::8b76:ddc8:61ad:15be/64 scope link noprefixroute
       valid_lft forever preferred_lft forever
3: ens34: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP group default qlen 1000
    link/ether 00:0c:29:8b:37:cb brd ff:ff:ff:ff:ff:ff
    inet 192.168.52.128/24 brd 192.168.52.255 scope global dynamic noprefixroute ens34
       valid_lft 983sec preferred_lft 983sec
    inet6 fe80::97a0:949d:33c8:526f/64 scope link noprefixroute
       valid_lft forever preferred_lft forever

</code>

Observăm că avem 2 interfețe de rețea: ''ens33'' și ''ens34'', precum și interfața ''lo'' sau ''loopback'' (despre care vom vorbi în câteva momente). Fiecărei interfețe îi este asignată o adresă IP: ''192.168.232.206/24'' și ''192.168.52.128/24'', respetiv ''127.0.0.1/8'' pentru cea de loopback. (pe stațiile voastre cel mai probabil adresele IP ale primelor 2 interfețe vor fi diferite)

''Localhost'' este un nume de host care înseamnă ''acest calculator'' și poate fi utilizat pentru accesarea propriilor servicii de rețea prin interfața să de ''loopback''. Practic, este un mod de a ne identifica pe noi înșine. Utilizarea interfeței de loopback evită placa de rețea. Mecanismul de loopback local poate fi util pentru testarea software-ului în timpul dezvoltării, independent de alte configurări de rețea. Spre exemplu, dacă avem un server web care rulează local, îl putem accesa la ''http://localhost/'' într-un browser.

După cum am văzut și mai sus, localhost se rezolvă în adresa ip ''127.0.0.1''.

<note>

In loc să scriem ''ip address show'', putem folosi prescurtarea ''ip a s''.

</note>

==== 1. Comanda ping ====

Pentru a verifica dacă un anumit calculator poate fi accesat prin intermediul unei rețele de tip IP, putem folosi comanda ''ping''.

Ne putem da ping nouă înșine folosind interfața de loopback, adică adresa IP ''127.0.0.1''. (întrerupem cu CTRL+C după 2-3 pachete trimise)

<code bash>

student@uso:~$ ping 127.0.0.1
PING 127.0.0.1 (127.0.0.1) 56(84) bytes of data.
64 bytes from 127.0.0.1: icmp_seq=1 ttl=64 time=0.021 ms
64 bytes from 127.0.0.1: icmp_seq=2 ttl=64 time=0.029 ms
64 bytes from 127.0.0.1: icmp_seq=3 ttl=64 time=0.031 ms
^C
--- 127.0.0.1 ping statistics ---
3 packets transmitted, 3 received, 0% packet loss, time 2051ms
rtt min/avg/max/mdev = 0.021/0.027/0.031/0.004 ms


</code>

Deoarece stațiile din laborator sunt în aceeași rețea, putem da ping unui coleg. El va trebui să ruleze ''ip a s'' pe stația lui și să ne zică adresa sa IP. Să presupunem de exemplu că adresa IP a colegului este ''192.168.232.206''.


<code bash>

student@uso:~$ ping  192.168.232.206
PING 192.168.232.206 (192.168.232.206) 56(84) bytes of data.
64 bytes from 192.168.232.206: icmp_seq=1 ttl=64 time=0.022 ms
64 bytes from 192.168.232.206: icmp_seq=2 ttl=64 time=0.029 ms
^C
--- 192.168.232.206 ping statistics ---
2 packets transmitted, 2 received, 0% packet loss, time 1029ms
rtt min/avg/max/mdev = 0.022/0.025/0.029/0.006 ms


</code>

Putem da ping la un nume din internet, de exemplu ''google.ro''. Este de asemenea o metodă usoară de a determina adresa IP la care ''google.ro'' este rezolvat de către serverul de DNS.

<code bash>

student@uso:~$ ping google.ro
PING google.ro (216.58.214.67) 56(84) bytes of data.
64 bytes from fra15s10-in-f3.1e100.net (216.58.214.67): icmp_seq=1 ttl=128 time=31.6 ms
64 bytes from fra15s10-in-f3.1e100.net (216.58.214.67): icmp_seq=2 ttl=128 time=31.3 ms

</code>

==== 2. DNS ====

Dacă tot am vorbit de DNS mai sus și am arătat o metodă ușoară de a afla adresa IP a lui ''google.ro'', este important de precizat că putem folosi comanda ''host'' pentru un DNS lookup sau reverse lookup. Vrem pentru început să facem un ''lookup'' pentru ''google.ro''.

<code bash>

student@uso:~$ host google.ro
google.ro has address 216.58.207.35
google.ro has IPv6 address 2a00:1450:4001:814::2003
google.ro mail is handled by 50 alt4.aspmx.l.google.com.
google.ro mail is handled by 30 alt2.aspmx.l.google.com.
google.ro mail is handled by 20 alt1.aspmx.l.google.com.
google.ro mail is handled by 10 aspmx.l.google.com.
google.ro mail is handled by 40 alt3.aspmx.l.google.com.

</code>

Dacă vrem să știm cărui nume îi este asociat o adresă IP, folosim tot host astfel:

<code bash>

student@uso:~$ host 141.85.227.151
151.227.85.141.in-addr.arpa domain name pointer acs.pub.ro.

</code>

Și observăm că IP-ul ''141.85.227.151'' corespunde numelui ''acs.pub.ro''.

Apare întrebarea "de unde știe calculatorul nostru să afle adresa IP a lui ''acs.pub.ro''?". Răspunsul este fișierul de configurare ''/etc/resolv.conf''. Aici sunt configurate name server-ele pe care calculatorul nostru le va folosi. Un exemplu de fișier de configurare:

Dacă vrem să știm cărui nume îi este asociat o adresa IP, folosim tot host astfel:

<code bash>

nameserver 192.168.0.100
nameserver 8.8.8.8
nameserver 8.8.4.4

</code>

==== 2. Gateway si rutare in internet ====

În momentul de față, stația noastră se află într-o rețea privată aflată sub un router. La rândul lui acest router se poate afla într-o altă rețea și tot așa. Când trimitem un pachet în internet (de exemplu un ping), el va fi rutat de mai multe ori prin diferite rețele până va ajunge la destinație. Aceste rutări să numesc 'hopuri', iar pentru a vedea prin câte hopuri trece un pachet putem folosi utilitarul ''traceroute''. (Dacă nu există, rulați ''sudo apt-get install traceroute''). Exemplu de output pentru comanda traceroute:

<code bash>

student@uso:~$ traceroute google.ro

Tracing route to google.ro [172.217.21.195]
over a maximum of 30 hops:

  1    <1 ms    <1 ms     2 ms  192.168.0.1
  2    <1 ms    <1 ms     1 ms  10-22-4-1.eregie.pub.ro [10.22.4.1]
  3     1 ms     1 ms     1 ms  r-c3550-l3-vlan11.bucharest.roedu.net [141.85.0.65]
  4     1 ms     1 ms     1 ms  141.85.133.65
  5     1 ms     1 ms     1 ms  po-23.acc1.buc.roedu.net [37.128.225.225]
  6     5 ms     2 ms     3 ms  bu-13.core2.buc.roedu.net [37.128.232.177]
  7     3 ms     3 ms     3 ms  hu-0-0-0-0.core3.nat.roedu.net [37.128.239.101]
  8     1 ms     2 ms     1 ms  te-0-6-0-1.peers1.nat.roedu.net [37.128.239.42]
  9    29 ms    29 ms    29 ms  Fra.RoNIX.Ro [217.156.113.94]
 10    30 ms    30 ms    30 ms  ^C

</code>

Spuneam mai devreme că stația noastră se află într-o rețea privată. Pentru a ieși în internet, este nevoie de un nod în această rețea care să aibe rolul de ''default gateway''. În cazul nostru este un router ce trimite mai departe în afara rețelei pachetele trimise din interiorul ei, dar și ruteaza pachetele venite din exterior către stația destinație din rețeaua privată.

Pentru a vedea adresa IP a 'default gateway-ului' folosim comanda ''ip route'' sau ''ip r'' (prescurtat).

<code bash>

student@uso:~$ ip route
default via 192.168.232.2 dev ens33 proto dhcp metric 100

</code>

Observăm că în acest caz, default gateway-ul are adresa IP ''192.168.232.2''.

Adresa IP a calculatorului nostru este una privată în acest moment. Este util să știm și ce adresa publică avem, mai exact adresa cu care ieșim în internet. Această adresa IP publică nu este știută local, și deci este nevoie de un request extern pentru a o afla. Cel mai simplu este să folosim utilitarul ''curl'' și pagina ''ipinfo.io/ip''.

<code bash>

student@uso:~$ curl ipinfo.io/ip
141.85.0.122

</code>

==== 3. Dhclient si ssh pe mașina virtuală ====

Presupunem că am conectat laptopul personal la o rețea de internet, dar observăm că nu avem și o adresa IP atribuită interfeței de rețea. O modalitate ușoară de a realiza automat configurarile de rețea este să folosim ''dhclient''. Se folosește de protocolul DHCP pentru a configura interfața respectivă.

De multe ori ne este incomod să lucrăm în CLI-ul din mașina virtuală, de exemplu nu puteam da COPY/PASTE de acolo. O modalitate bună de a scapa de problema asta este să ne conectăm de pe stația locală pe mașină virtuală prin ''ssh''. Pentru acest lucru este nevoie să aflăm adresa IP a mașinii virtuale (cum am arătat mai sus) și să rulăm următoarea comandă: (introducem parola ''student'')

<code bash>

student@uso:~$ ssh student@192.168.232.206

</code>

