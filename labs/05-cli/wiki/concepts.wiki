===== Concepte =====

==== Fluxuri standard ====
În lumea calculatoarelor, programele funcționează pe același principiu 
indiferent de scop, limbaj sau sistem de operare, și anume primesc un
set de date de intrare pe care îl prelucrează și se obține un set de 
date de ieșire. Bineînțeles, erorile fac parte din viața noastră, 
așadar nu le putem ignora nici în cazul programelor.

Pentru a ne obișnui cu aceste concepte, introducem 3 termeni noi:
    - stdin (fluxul standard de intrare/standard input) - 0
    - stdout (fluxul standard de ieșire/standard output) - 1
    - stderr (fluxul standard de eroare/standard error) - 2
De cele mai multe ori, stdin este reprezentat de tastatură, iar stdout 
și stderr de terminal.

<note>
Numerele ''0'', ''1'' și ''2'' reprezintă ''descriptorii de fișier'' pentru 
fluxurile standar prezentate.
</note>

==== Redirectări ====
De multe ori avem de a face cu un set de date foarte mare și dinamic 
și este pur și simplu inconvenabil să introducem datele manual de la 
tastatură, așadar, pentru a ne face viața mai ușoară, avem posibilitatea 
de a redirecta inputul unui program. Asta înseamnă că modificăm fluxul 
standard de intrare cu ce vrem noi, un fișier, un pipe (TODO add link), 
un device etc. Pentru a redirecta inputul folosim operatorul ''<''.

Să presupunem că un program primește ceva date de intrare, dar produce un 
set foarte mare de date de ieșire pe care vrem să le salvăm pentru o analiză 
ulterioară. Este util în acest caz să redirectăm fluxul de ieșire către un fișier.
Pentru a redirecta output-ul unui program vom folosi operatorul ''>''.

În ceea ce privește redirectarea erorilor, lucrurile stau similar cu ceea ce 
am văzut la fluxul de ieșire. Pentru a redirecta erorile produse de un program 
folosim operatorul ''2>''. Atunci când vrem să ignorăm erorile apărute (TODO exemplu 
cu find când nu are permisiuni) ne putem folosi de ''/dev/null''.

<note>
La o singură rulare a unui program ne putem juca cu redirectările oricum vrem, adică 
putem redirecta chiar și toate fluxurile deodată. Pentru a produce acest efect doar 
trebuie să înlănțuim redirectările (TODO fix exprimare + exemple).
</note>

==== Înlănțuirea comenzilor ====
În Linux avem posibilitatea de a executa mai multe comenezi, una după cealaltă, 
indiferent de rezultatul obținut de la fiecare folosind ''înlănțuirea comenzilor''.
Pentru a înlănțui cel puțin două comenzi, folosim operatorul '';''. (TODO exemplu)

==== Procese ====
În termeni largi, un ''proces'' este o instanță a execuției unui program. Este important 
să înțelegem care este legătura dintre shell, rularea unui program și procesul din spatele 
acestuia. La rularea oricărui binar (să zicem ''ls''), shell-ul execută ''fork()'' care 
crează o clonă a procesului curent (adică cel al shell-ului), după care execută ''exec()'' 
care încarcă binarul cerut în memoria noului proces creat. Astfel, la rularea comenzii 
''ls'' vor exista în sistem, pe lângă multe altele, două procese - shell-ul curent și 
ls (TODO altă exprimare, e grea acum).

==== Comunicarea între procese ====
O situație foarte des întâlnită în lumea calulatoarelor este comunicarea dintre două 
sau mai multe procese. Există situații în care vrem ca outputul unui program (sau a 
une comezni în cazul terminalului) să fie considerat drept inputul altuia. Pentru a 
realiza acest lucru în linia de comandă, folosim operatorul ''|'' numit ''pipe''.
(TODO exemplu)

==== Variabile ====
=== Variabile de shell ===
=== Variabile de mediu ===
=== Variabile în shell ===

==== Avantaje și dezavantaje CLI vs. GUI ====

==== Și în final.. ce înseamnă automatizare? ====

